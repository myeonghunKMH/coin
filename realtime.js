// realtime.js - ÌÜµÌï©Îêú Ïã§ÏãúÍ∞Ñ Í±∞Îûò Í∏∞Îä•
const WebSocket = require("ws");
const { v4: uuidv4 } = require("uuid");
const axios = require("axios");
const db = require("./services/database.js");

// ÏÑ§Ï†ïÍ∞í
const CONFIG = {
  MARKET_CODES: ["KRW-BTC", "KRW-ETH", "KRW-XRP"],
  UPBIT_WS_URL: "wss://api.upbit.com/websocket/v1",
  DEFAULT_USER: "testuser", // Í∏∞Î≥∏ ÏÇ¨Ïö©Ïûê (Ï∂îÌõÑ Ïã§Ï†ú ÏÇ¨Ïö©ÏûêÎ°ú Î≥ÄÍ≤Ω)
};

// KRW Ïú†Ìã∏Î¶¨Ìã∞ (database.jsÏôÄ ÎèôÏùº)
const KRWUtils = db.KRWUtils;

// Ï£ºÎ¨∏ Îß§Ïπ≠ ÏóîÏßÑ ÌÅ¥ÎûòÏä§
class OrderMatchingEngine {
  constructor(dbManager) {
    this.db = dbManager;
    this.isProcessing = false;
    this.processingMarkets = new Set();
  }

  async processOrderbook(market, orderbookData) {
    if (this.processingMarkets.has(market) || !orderbookData?.orderbook_units) {
      return;
    }

    this.processingMarkets.add(market);

    try {
      const pendingOrders = await this.db.getMarketPendingOrders(market);
      if (pendingOrders.length === 0) return;

      const buyOrders = pendingOrders.filter((order) => order.side === "bid");
      const sellOrders = pendingOrders.filter((order) => order.side === "ask");

      const asks = orderbookData.orderbook_units
        .map((unit) => ({
          price: KRWUtils.toInteger(unit.ask_price),
          size: unit.ask_size,
        }))
        .filter((ask) => ask.price > 0 && ask.size > 0);

      const bids = orderbookData.orderbook_units
        .map((unit) => ({
          price: KRWUtils.toInteger(unit.bid_price),
          size: unit.bid_size,
        }))
        .filter((bid) => bid.price > 0 && bid.size > 0);

      for (const buyOrder of buyOrders) {
        await this.matchBuyOrder(buyOrder, asks);
      }

      for (const sellOrder of sellOrders) {
        await this.matchSellOrder(sellOrder, bids);
      }
    } catch (error) {
      console.error(`‚ùå Ï£ºÎ¨∏ Îß§Ïπ≠ Ï≤òÎ¶¨ Ïò§Î•ò (${market}):`, error);
    } finally {
      this.processingMarkets.delete(market);
    }
  }

  async matchBuyOrder(buyOrder, asks) {
    const orderPrice = KRWUtils.toInteger(buyOrder.price);
    const matchableAsks = asks
      .filter((ask) => ask.price <= orderPrice)
      .sort((a, b) => a.price - b.price);

    if (matchableAsks.length === 0) return;

    let remainingQuantity = buyOrder.remaining_quantity;

    for (const ask of matchableAsks) {
      if (remainingQuantity <= 0.00000001) break;

      const executableQuantity = Math.min(remainingQuantity, ask.size);
      const executionPrice = ask.price;

      if (executableQuantity > 0.00000001) {
        console.log(`üí∞ Îß§Ïàò Ï≤¥Í≤∞: ${buyOrder.market} - Í∞ÄÍ≤©: ${executionPrice.toLocaleString()}, ÏàòÎüâ: ${executableQuantity}`);

        await this.executeTrade(
          buyOrder,
          executionPrice,
          executableQuantity,
          remainingQuantity - executableQuantity
        );

        remainingQuantity -= executableQuantity;
        ask.size -= executableQuantity;
      }
    }
  }

  async matchSellOrder(sellOrder, bids) {
    const orderPrice = KRWUtils.toInteger(sellOrder.price);
    const matchableBids = bids
      .filter((bid) => bid.price >= orderPrice)
      .sort((a, b) => b.price - a.price);

    if (matchableBids.length === 0) return;

    let remainingQuantity = sellOrder.remaining_quantity;

    for (const bid of matchableBids) {
      if (remainingQuantity <= 0.00000001) break;

      const executableQuantity = Math.min(remainingQuantity, bid.size);
      const executionPrice = bid.price;

      if (executableQuantity > 0.00000001) {
        console.log(`üí∏ Îß§ÎèÑ Ï≤¥Í≤∞: ${sellOrder.market} - Í∞ÄÍ≤©: ${executionPrice.toLocaleString()}, ÏàòÎüâ: ${executableQuantity}`);

        await this.executeTrade(
          sellOrder,
          executionPrice,
          executableQuantity,
          remainingQuantity - executableQuantity
        );

        remainingQuantity -= executableQuantity;
        bid.size -= executableQuantity;
      }
    }
  }

  async executeTrade(order, executionPrice, executedQuantity, remainingQuantity) {
    const totalAmount = KRWUtils.calculateTotal(executionPrice, executedQuantity);

    if (remainingQuantity < 0.00000001) {
      remainingQuantity = 0;
    }

    try {
      await this.executeOrderFillTransaction(
        order.user_id,
        order.id,
        order.market,
        order.side,
        executionPrice,
        executedQuantity,
        totalAmount,
        remainingQuantity
      );

      const status = remainingQuantity <= 0 ? "filled" : "partial";
      
      // Ï≤¥Í≤∞ ÏïåÎ¶º Ï†ÑÏÜ°
      if (this.wsManager) {
        this.wsManager.broadcastOrderFillNotification(order.user_id, {
          userId: order.user_id,
          orderId: order.id,
          market: order.market,
          side: order.side,
          executionPrice: executionPrice,
          executedQuantity: executedQuantity,
          remainingQuantity: remainingQuantity,
          totalAmount: totalAmount,
          status: status,
        });
      }

      console.log(`‚úÖ Ï≤¥Í≤∞ ÏôÑÎ£å - Ï£ºÎ¨∏ID: ${order.id}, Ï≤¥Í≤∞Í∞Ä: ${executionPrice.toLocaleString()}, ÏÉÅÌÉú: ${status}`);
    } catch (error) {
      console.error(`‚ùå Í±∞Îûò Ï≤¥Í≤∞ Ï≤òÎ¶¨ Ïã§Ìå® (Ï£ºÎ¨∏ID: ${order.id}):`, error);
      throw error;
    }
  }

  async executeOrderFillTransaction(userId, orderId, market, side, executionPrice, executedQuantity, totalAmount, remainingQuantity) {
    const connection = await db.pool.getConnection();
    try {
      await connection.beginTransaction();

      const coinName = market.split("-")[1].toLowerCase();

      if (side === "bid") {
        await connection.execute(`
          UPDATE users 
          SET ${coinName}_balance = ${coinName}_balance + ?
          WHERE id = ?
        `, [executedQuantity, userId]);

        // Í∞ÄÍ≤© Ï∞®Ïù¥ ÌôòÎ∂à Ï≤òÎ¶¨
        const priceDifference = await this.getPriceDifference(connection, orderId, executionPrice);
        if (priceDifference > 0) {
          const refundAmount = KRWUtils.calculateTotal(priceDifference, executedQuantity);
          await connection.execute(`
            UPDATE users 
            SET krw_balance = krw_balance + ?
            WHERE id = ?
          `, [refundAmount, userId]);
          console.log(`üí∞ Îß§Ïàò Í∞ÄÍ≤©Ï∞®Ïù¥ ÌôòÎ∂à: ${refundAmount.toLocaleString()}Ïõê`);
        }
      } else {
        await connection.execute(`
          UPDATE users 
          SET krw_balance = krw_balance + ?
          WHERE id = ?
        `, [KRWUtils.toInteger(totalAmount), userId]);
      }

      await connection.execute(`
        INSERT INTO transactions (user_id, market, side, price, quantity, total_amount, type) 
        VALUES (?, ?, ?, ?, ?, ?, 'limit')
      `, [userId, market, side, KRWUtils.toInteger(executionPrice), executedQuantity, KRWUtils.toInteger(totalAmount)]);

      const newStatus = remainingQuantity <= 0.00000001 ? "filled" : "partial";

      await connection.execute(`
        UPDATE pending_orders 
        SET remaining_quantity = ?, status = ?, updated_at = NOW()
        WHERE id = ?
      `, [remainingQuantity, newStatus, orderId]);

      await connection.commit();
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }

  async getPriceDifference(connection, orderId, executionPrice) {
    const [rows] = await connection.execute(`
      SELECT price FROM pending_orders WHERE id = ?
    `, [orderId]);
    
    if (rows.length > 0) {
      const orderPrice = rows[0].price;
      return Math.max(0, orderPrice - executionPrice);
    }
    return 0;
  }

  setWebSocketManager(wsManager) {
    this.wsManager = wsManager;
  }
}

// ÏõπÏÜåÏºì Îß§ÎãàÏ†Ä ÌÅ¥ÎûòÏä§
class WebSocketManager {
  constructor(clientWebSocketServer) {
    this.upbitWs = null;
    this.clientWss = clientWebSocketServer;
    this.currentMarketPrices = {};
    this.latestOrderbooks = {};
    this.isConnected = false;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 10;
    this.heartbeatInterval = null;

    // Ï£ºÎ¨∏ Îß§Ïπ≠ ÏóîÏßÑ Ï¥àÍ∏∞Ìôî
    this.matchingEngine = new OrderMatchingEngine(db);
    this.matchingEngine.setWebSocketManager(this);
  }

  connect() {
    this.upbitWs = new WebSocket(CONFIG.UPBIT_WS_URL);

    this.upbitWs.onopen = () => {
      console.log("‚úÖ ÏóÖÎπÑÌä∏ ÏõπÏÜåÏºì ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞ÎêòÏóàÏäµÎãàÎã§.");
      this.isConnected = true;
      this.reconnectAttempts = 0;
      this.sendSubscriptionRequest();
      this.startHeartbeat();
    };

    this.upbitWs.onmessage = (event) => {
      this.handleMessage(event);
    };

    this.upbitWs.onclose = (event) => {
      console.log(`‚ö†Ô∏è ÏóÖÎπÑÌä∏ ÏõπÏÜåÏºì Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥Ï°åÏäµÎãàÎã§. ÏΩîÎìú: ${event.code}, Ïù¥Ïú†: ${event.reason}`);
      this.isConnected = false;
      this.stopHeartbeat();
      this.handleReconnection();
    };

    this.upbitWs.onerror = (error) => {
      console.error("‚ùå ÏóÖÎπÑÌä∏ ÏõπÏÜåÏºì Ïò§Î•ò:", error);
      this.isConnected = false;
    };
  }

  handleReconnection() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);

      console.log(`Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ ${this.reconnectAttempts}/${this.maxReconnectAttempts} (${delay / 1000}Ï¥à ÌõÑ)`);

      setTimeout(() => this.connect(), delay);
    } else {
      console.error("‚ùå ÏõπÏÜåÏºì Ïû¨Ïó∞Í≤∞ Ïã§Ìå® - ÏµúÎåÄ ÏãúÎèÑ ÌöüÏàò Ï¥àÍ≥º");
    }
  }

  startHeartbeat() {
    this.heartbeatInterval = setInterval(() => {
      if (this.upbitWs && this.upbitWs.readyState === WebSocket.OPEN) {
        this.upbitWs.ping();
      }
    }, 30000);
  }

  stopHeartbeat() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
  }

  sendSubscriptionRequest() {
    const requestMessage = [
      { ticket: uuidv4() },
      { type: "ticker", codes: CONFIG.MARKET_CODES },
      { type: "orderbook", codes: CONFIG.MARKET_CODES, level: 0 },
      { type: "orderbook", codes: ["KRW-BTC"], level: 1000000 },
      { type: "orderbook", codes: ["KRW-ETH"], level: 10000 },
      { type: "orderbook", codes: ["KRW-XRP"], level: 1 },
      { format: "DEFAULT" },
    ];

    this.upbitWs.send(JSON.stringify(requestMessage));
    console.log("üì° ÏóÖÎπÑÌä∏ ÏõπÏÜåÏºì Íµ¨ÎèÖ ÏöîÏ≤≠ Ï†ÑÏÜ° ÏôÑÎ£å");
  }

  async handleMessage(event) {
    try {
      const data = JSON.parse(event.data);

      if (data.type === "ticker") {
        this.handleTickerData(data);
      } else if (data.type === "orderbook") {
        await this.handleOrderbookData(data);
      }

      this.broadcastToClients(event.data);
    } catch (error) {
      console.error("ÏõπÏÜåÏºì Î©îÏãúÏßÄ Ï≤òÎ¶¨ Ïò§Î•ò:", error);
    }
  }

  handleTickerData(data) {
    const code = data.code;
    if (!CONFIG.MARKET_CODES.includes(code)) return;

    this.currentMarketPrices[code] = KRWUtils.toInteger(data.trade_price);

    if (!this.latestOrderbooks[code]) {
      this.latestOrderbooks[code] = {};
    }
    this.latestOrderbooks[code].lastPrice = this.currentMarketPrices[code];
  }

  async handleOrderbookData(data) {
    const code = data.code;
    if (!CONFIG.MARKET_CODES.includes(code)) return;

    this.latestOrderbooks[code] = {
      ...this.latestOrderbooks[code],
      data: data,
      lastUpdated: Date.now(),
    };

    if (data.level === 0) {
      setImmediate(async () => {
        try {
          await this.matchingEngine.processOrderbook(code, data);
        } catch (error) {
          console.error(`Ï£ºÎ¨∏ Îß§Ïπ≠ Ï≤òÎ¶¨ Ïò§Î•ò (${code}):`, error);
        }
      });
    }
  }

  broadcastToClients(data) {
    const connectedClients = Array.from(this.clientWss.clients).filter(
      (client) => client.readyState === WebSocket.OPEN
    );

    if (connectedClients.length > 0) {
      connectedClients.forEach((client) => {
        try {
          client.send(data);
        } catch (error) {
          console.error("ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïò§Î•ò:", error);
        }
      });
    }
  }

  broadcastOrderFillNotification(userId, orderDetails) {
    const notification = {
      type: "order_filled",
      userId: userId,
      timestamp: Date.now(),
      data: {
        ...orderDetails,
        executionTime: new Date().toISOString(),
        marketPrice: this.currentMarketPrices[orderDetails.market],
      },
    };

    console.log(`üì¢ Ï≤¥Í≤∞ ÏïåÎ¶º Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏: ÏÇ¨Ïö©Ïûê ${userId}, ${orderDetails.market} ${orderDetails.side}`);

    this.clientWss.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        try {
          client.send(JSON.stringify(notification));
        } catch (error) {
          console.error("Ï≤¥Í≤∞ ÏïåÎ¶º Ï†ÑÏÜ° Ïò§Î•ò:", error);
        }
      }
    });
  }

  getCurrentPrice(market) {
    const price = this.currentMarketPrices[market];
    if (!price) {
      console.warn(`‚ö†Ô∏è ${market}Ïùò ÌòÑÏû¨ Í∞ÄÍ≤© Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§.`);
      return 0;
    }
    return price;
  }

  getIntegerPrices() {
    const integerPrices = {};
    Object.keys(this.currentMarketPrices).forEach((market) => {
      integerPrices[market] = KRWUtils.toInteger(this.currentMarketPrices[market]);
    });
    return integerPrices;
  }

  close() {
    console.log("üîå ÏõπÏÜåÏºì Îß§ÎãàÏ†Ä Ï¢ÖÎ£å Ï§ë...");

    this.stopHeartbeat();

    if (this.upbitWs) {
      this.upbitWs.close();
    }

    this.clientWss.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.close(1000, "ÏÑúÎ≤Ñ Ï¢ÖÎ£å");
      }
    });

    console.log("‚úÖ ÏõπÏÜåÏºì Îß§ÎãàÏ†Ä Ï¢ÖÎ£å ÏôÑÎ£å");
  }
}

// Í±∞Îûò ÏÑúÎπÑÏä§ ÌÅ¥ÎûòÏä§
class TradingService {
  constructor(wsManager) {
    this.ws = wsManager;
  }

  calculateTradeAmounts(market, side, type, normalizedPrice, normalizedQuantity) {
    let finalPrice, finalQuantity, totalAmount;

    if (type === "market") {
      const currentPrice = this.ws.getCurrentPrice(market);
      if (!currentPrice) {
        throw new Error("ÌòÑÏû¨ ÏãúÏû•Í∞ÄÎ•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.");
      }

      if (side === "bid") {
        totalAmount = KRWUtils.toInteger(normalizedPrice);
        finalPrice = KRWUtils.toInteger(currentPrice);
        finalQuantity = totalAmount / finalPrice;
      } else {
        finalQuantity = normalizedQuantity;
        finalPrice = KRWUtils.toInteger(currentPrice);
        totalAmount = KRWUtils.calculateTotal(finalPrice, finalQuantity);
      }
    } else {
      finalPrice = KRWUtils.toInteger(normalizedPrice);
      finalQuantity = normalizedQuantity;
      totalAmount = KRWUtils.calculateTotal(finalPrice, finalQuantity);
    }

    return { finalPrice, finalQuantity, totalAmount };
  }

  async executeOrder(market, side, type, normalizedPrice, normalizedQuantity, username) {
    const userId = await db.getUserByUsername(username);
    if (!userId) {
      throw new Error("ÏÇ¨Ïö©ÏûêÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
    }

    const { finalPrice, finalQuantity, totalAmount } = this.calculateTradeAmounts(
      market, side, type, normalizedPrice, normalizedQuantity
    );

    if (type === "limit") {
      await this.reserveBalanceForLimitOrder(userId, market, side, finalPrice, finalQuantity, totalAmount);
      return await db.createPendingOrder(userId, market, side, finalPrice, finalQuantity, totalAmount, type);
    } else {
      await db.executeTradeTransaction(userId, market, side, finalPrice, finalQuantity, totalAmount, type);
      return {
        market, side, type,
        price: KRWUtils.toInteger(finalPrice),
        quantity: finalQuantity,
        totalAmount: KRWUtils.toInteger(totalAmount),
      };
    }
  }

  async reserveBalanceForLimitOrder(userId, market, side, price, quantity, totalAmount) {
    const connection = await db.pool.getConnection();
    try {
      await connection.beginTransaction();

      if (side === "bid") {
        const requiredAmount = KRWUtils.toInteger(totalAmount);
        const [balanceResult] = await connection.execute(`
          SELECT krw_balance FROM users WHERE id = ? FOR UPDATE
        `, [userId]);

        const currentBalance = KRWUtils.toInteger(balanceResult[0]?.krw_balance || 0);
        if (currentBalance < requiredAmount) {
          throw new Error("ÏûîÏï°Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§.");
        }

        const newBalance = currentBalance - requiredAmount;
        await connection.execute(`
          UPDATE users SET krw_balance = ? WHERE id = ?
        `, [newBalance, userId]);

        console.log(`üí∞ Îß§Ïàò Ï£ºÎ¨∏ ÏûîÍ≥† ÏòàÏïΩ: ${requiredAmount.toLocaleString()}Ïõê Ï∞®Í∞ê`);
      } else {
        const coinName = market.split("-")[1].toLowerCase();
        const [balanceResult] = await connection.execute(`
          SELECT ${coinName}_balance FROM users WHERE id = ? FOR UPDATE
        `, [userId]);

        const currentCoinBalance = balanceResult[0]?.[`${coinName}_balance`] || 0;
        if (currentCoinBalance < quantity) {
          throw new Error("Î≥¥Ïú† ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§.");
        }

        const newCoinBalance = currentCoinBalance - quantity;
        await connection.execute(`
          UPDATE users SET ${coinName}_balance = ? WHERE id = ?
        `, [newCoinBalance, userId]);

        console.log(`ü™ô Îß§ÎèÑ Ï£ºÎ¨∏ ÏûîÍ≥† ÏòàÏïΩ: ${quantity}Í∞ú ${coinName.toUpperCase()} Ï∞®Í∞ê`);
      }

      await connection.commit();
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }
}

// Î©îÏù∏ Îì±Î°ù Ìï®Ïàò
function registerRealtime(app, wss) {
  console.log("üöÄ Ïã§ÏãúÍ∞Ñ Í±∞Îûò ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî Ï§ë...");

  // ÏõπÏÜåÏºì Îß§ÎãàÏ†Ä Ï¥àÍ∏∞Ìôî
  const wsManager = new WebSocketManager(wss);
  const tradingService = new TradingService(wsManager);

  // ÏõπÏÜåÏºì Ïó∞Í≤∞ ÏãúÏûë
  wsManager.connect();

  // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ï≤òÎ¶¨
  wss.on("connection", (ws, req) => {
    const clientIP = req.socket.remoteAddress;
    console.log(`üîó ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞Îê® (IP: ${clientIP})`);

    const prices = wsManager.getIntegerPrices();
    if (Object.keys(prices).length > 0) {
      ws.send(JSON.stringify({
        type: "initial_prices",
        data: prices,
      }));
    }

    ws.on("close", () => {
      console.log(`üîå ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ ÎÅäÍπÄ (IP: ${clientIP})`);
    });

    ws.on("error", (error) => {
      console.error("ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏõπÏÜåÏºì Ïò§Î•ò:", error);
    });
  });

  // Í±∞Îûò Í¥ÄÎ†® API ÎùºÏö∞Ìä∏ Ï∂îÍ∞Ä
  setupTradingRoutes(app, tradingService);

  console.log("‚úÖ Ïã§ÏãúÍ∞Ñ Í±∞Îûò ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å");

  // Ï†ïÎ¶¨ Ìï®Ïàò Î∞òÌôò
  return {
    close: () => {
      wsManager.close();
    }
  };
}

// Í±∞Îûò Í¥ÄÎ†® API ÎùºÏö∞Ìä∏ ÏÑ§Ï†ï
function setupTradingRoutes(app, tradingService) {
  // ÏûîÍ≥† Ï°∞Ìöå
  app.get("/api/balance", async (req, res) => {
  try {
    // üîß Í∞úÏÑ†: Ïã§Ï†ú Î°úÍ∑∏Ïù∏Îêú ÏÇ¨Ïö©Ïûê Ïö∞ÏÑ†, ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ ÏÇ¨Ïö©Ïûê
    let username = CONFIG.DEFAULT_USER;
    
    if (req.user?.email) {
      username = req.user.email;
    } else if (req.user?.preferred_username) {
      username = req.user.preferred_username;
    }
    
    console.log(`üìä ÏûîÍ≥† Ï°∞Ìöå ÏöîÏ≤≠: ${username}`);
    
    const balance = await db.getUserBalance(username);

    if (!balance) {
      // üîß ÏÇ¨Ïö©ÏûêÍ∞Ä ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ ÏûîÍ≥†Î°ú Ï¥àÍ∏∞Ìôî ÏãúÎèÑ
      console.log(`ÏÉà ÏÇ¨Ïö©Ïûê ÏûîÍ≥† Ï¥àÍ∏∞Ìôî: ${username}`);
      
      // users ÌÖåÏù¥Î∏îÏóê ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Í∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏ ÌõÑ ÏûîÍ≥† Ï¥àÍ∏∞Ìôî
      if (req.user?.id) {
        await db.pool.execute(`
          UPDATE users 
          SET 
            krw_balance = COALESCE(krw_balance, 1000000),
            btc_balance = COALESCE(btc_balance, 0.00000000),
            eth_balance = COALESCE(eth_balance, 0.00000000),
            xrp_balance = COALESCE(xrp_balance, 0.00000000)
          WHERE id = ?
        `, [req.user.id]);
        
        // Îã§Ïãú Ï°∞Ìöå
        const newBalance = await db.getUserBalance(username);
        if (newBalance) {
          const processedBalance = db.KRWUtils.processBalance(newBalance);
          return res.json(processedBalance);
        }
      }
      
      // Í∑∏ÎûòÎèÑ ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞í Î∞òÌôò
      return res.json({
        krw_balance: 1000000,
        btc_balance: 0.00000000,
        eth_balance: 0.00000000,
        xrp_balance: 0.00000000
      });
    }

    const processedBalance = db.KRWUtils.processBalance(balance);
    res.json(processedBalance);
  } catch (err) {
    console.error("ÏûîÍ≥† Ï°∞Ìöå Ïò§Î•ò:", err);
    res.status(500).json({
      error: "ÏÑúÎ≤Ñ Ïò§Î•ò: ÏûîÍ≥† Ï°∞ÌöåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.",
      code: "INTERNAL_ERROR",
    });
  }
});

  // Í±∞Îûò Ï£ºÎ¨∏
  app.post("/api/trade", async (req, res) => {
  try {
    const { market, side, type, price, quantity } = req.body;
    
    // üîß Í∞úÏÑ†: Ïã§Ï†ú Î°úÍ∑∏Ïù∏Îêú ÏÇ¨Ïö©Ïûê Ïö∞ÏÑ†
    let username = CONFIG.DEFAULT_USER;
    
    if (req.user?.email) {
      username = req.user.email;
    } else if (req.user?.preferred_username) {
      username = req.user.preferred_username;
    }
    
    console.log(`üìà Í±∞Îûò Ï£ºÎ¨∏ ÏöîÏ≤≠: ${username} - ${market} ${side} ${type}`);

    // ÏûÖÎ†•Í∞í Í≤ÄÏ¶ù
    if (!market || !side || !type) {
      return res.status(400).json({
        error: "ÌïÑÏàò ÌïÑÎìúÍ∞Ä ÎàÑÎùΩÎêòÏóàÏäµÎãàÎã§.",
        code: "MISSING_FIELDS",
      });
    }

    const normalizedPrice = db.KRWUtils.parseNumber(price);
    const normalizedQuantity = db.KRWUtils.parseNumber(quantity);

    const orderDetails = await tradingService.executeOrder(
      market, side, type, normalizedPrice, normalizedQuantity, username
    );

    res.status(200).json({
      message: "Ï£ºÎ¨∏Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ëÏàòÎêòÏóàÏäµÎãàÎã§.",
      orderDetails,
    });
  } catch (error) {
    console.error("‚ùå Ï£ºÎ¨∏ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò Î∞úÏÉù:", error.message);
    res.status(500).json({
      error: error.message || "Ï£ºÎ¨∏ Ï≤òÎ¶¨ Ï§ë ÏÑúÎ≤Ñ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      code: "TRADE_PROCESSING_ERROR",
    });
  }
});

  // Ï∫îÎì§ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
  app.get("/api/candles", async (req, res) => {
    const { unit, market, count = 200, to } = req.query;
    const requestCount = Math.min(parseInt(count), 1000);

    if (!unit || !market) {
      return res.status(400).json({
        error: "unitÍ≥º market ÌååÎùºÎØ∏ÌÑ∞Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§.",
        code: "MISSING_PARAMETERS",
      });
    }

    try {
      const allCandles = [];
      let currentTo = to;
      let remaining = requestCount;

      while (remaining > 0) {
        const batchSize = Math.min(remaining, 200);
        let url;

        if (unit === "1D") {
          url = `https://api.upbit.com/v1/candles/days?market=${market}&count=${batchSize}`;
        } else {
          url = `https://api.upbit.com/v1/candles/minutes/${unit}?market=${market}&count=${batchSize}`;
        }

        if (currentTo && currentTo !== "undefined") {
          const encodedTo = encodeURIComponent(currentTo);
          url += `&to=${encodedTo}`;
        }

        console.log(`üì° ÏóÖÎπÑÌä∏ API Ìò∏Ï∂ú: ${url}`);

        const response = await axios.get(url, {
          headers: { "Accept-Encoding": "gzip, deflate" },
          timeout: 10000,
        });

        const data = response.data;
        if (data.length === 0) break;

        allCandles.push(...data);
        remaining -= data.length;

        if (data.length < batchSize) break;
        currentTo = data[data.length - 1].candle_date_time_utc;
      }

      console.log(`üìä Ï∫îÎì§ Îç∞Ïù¥ÌÑ∞ ${allCandles.length}Í∞ú Î∞òÌôò: ${market} ${unit}`);
      res.json(allCandles);
    } catch (error) {
      console.error("‚ùå Ï∫îÎì§ Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠ Ïò§Î•ò:", error.message);
      res.status(500).json({
        error: "Ï∫îÎì§ Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏ†∏Ïò§Îäî Îç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.",
        code: "CANDLE_DATA_ERROR",
      });
    }
  });

  // Í±∞Îûò ÎÇ¥Ïó≠ Ï°∞Ìöå
  app.get("/api/transactions", async (req, res) => {
    try {
      const { limit = 50, offset = 0 } = req.query;
      const username = req.user?.email || CONFIG.DEFAULT_USER;
      const userId = await db.getUserByUsername(username);

      if (!userId) {
        return res.status(404).json({
          error: "ÏÇ¨Ïö©ÏûêÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.",
          code: "USER_NOT_FOUND",
        });
      }

      const transactions = await db.getUserTransactions(userId, limit, offset);
      const processedTransactions = transactions.map((t) => db.KRWUtils.processTransaction(t));

      res.json(processedTransactions);
    } catch (error) {
      console.error("‚ùå Í±∞Îûò ÎÇ¥Ïó≠ Ï°∞Ìöå Ïò§Î•ò:", error);
      res.status(500).json({
        error: "Í±∞Îûò ÎÇ¥Ïó≠ Ï°∞ÌöåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.",
        code: "TRANSACTION_HISTORY_ERROR",
      });
    }
  });

  // ÎåÄÍ∏∞ Ï£ºÎ¨∏ Ï°∞Ìöå
  app.get("/api/pending-orders", async (req, res) => {
    try {
      const username = req.user?.email || CONFIG.DEFAULT_USER;
      const userId = await db.getUserByUsername(username);

      if (!userId) {
        return res.status(404).json({
          error: "ÏÇ¨Ïö©ÏûêÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.",
          code: "USER_NOT_FOUND",
        });
      }

      const orders = await db.getUserPendingOrders(userId);
      res.json(orders);
    } catch (error) {
      console.error("ÎåÄÍ∏∞ Ï£ºÎ¨∏ Ï°∞Ìöå Ïò§Î•ò:", error);
      res.status(500).json({
        error: "ÎåÄÍ∏∞ Ï£ºÎ¨∏ Ï°∞ÌöåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.",
        code: "PENDING_ORDERS_ERROR",
      });
    }
  });

  // ÎåÄÍ∏∞ Ï£ºÎ¨∏ Ï∑®ÏÜå
  app.delete("/api/pending-orders/:orderId", async (req, res) => {
    try {
      const { orderId } = req.params;
      const username = req.user?.email || CONFIG.DEFAULT_USER;

      if (!orderId || isNaN(orderId)) {
        return res.status(400).json({
          error: "Ïú†Ìö®Ìïú Ï£ºÎ¨∏ IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.",
          code: "INVALID_ORDER_ID",
        });
      }

      const userId = await db.getUserByUsername(username);
      if (!userId) {
        return res.status(404).json({
          error: "ÏÇ¨Ïö©ÏûêÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.",
          code: "USER_NOT_FOUND",
        });
      }

      const result = await db.cancelPendingOrder(userId, parseInt(orderId));
      res.json(result);
    } catch (error) {
      console.error("Ï£ºÎ¨∏ Ï∑®ÏÜå Ïò§Î•ò:", error);
      res.status(500).json({
        error: error.message || "Ï£ºÎ¨∏ Ï∑®ÏÜåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.",
        code: "CANCEL_ORDER_ERROR",
      });
    }
  });

  console.log("üìä Í±∞Îûò Í¥ÄÎ†® API ÎùºÏö∞Ìä∏ ÏÑ§Ï†ï ÏôÑÎ£å");
}

module.exports = registerRealtime;